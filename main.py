import asyncio
import requests
import json
import os
from typing import Dict, Any, List, Optional

# å¯¼å…¥AstrBot API
from astrbot.api.event import filter, AstrMessageEvent, MessageEventResult
from astrbot.api.star import Context, Star, register
from astrbot.api import logger

@register("bilibili_up_notifier", "AutoGenerated", "æ£€æµ‹Bç«™UPä¸»å‘å¸ƒæ–°è§†é¢‘å¹¶æé†’", "1.0.0", "https://github.com")
class BilibiliUpNotifier(Star):
    def __init__(self, context: Context):
        super().__init__(context)
        # æ’ä»¶åç§°å’Œæè¿°
        self.PLUGIN_NAME = "bilibili_up_notifier"
        self.PLUGIN_DESCRIPTION = "æ£€æµ‹Bç«™UPä¸»å‘å¸ƒæ–°è§†é¢‘å¹¶æé†’"
        
        # å­˜å‚¨UPä¸»æœ€åå‘å¸ƒè§†é¢‘çš„ä¿¡æ¯
        self.last_video_info = {}
        # å­˜å‚¨ç”¨æˆ·è®¢é˜…å…³ç³»
        self.subscriptions = {}
        # é…ç½®æ–‡ä»¶è·¯å¾„
        self.CONFIG_FILE = os.path.join(os.path.dirname(__file__), 'config.json')
        # ä¸Šä¸‹æ–‡å¯¹è±¡
        self.context = context
        
        # åŠ è½½é…ç½®
        self.load_config()
        
        # å¯åŠ¨å®šæ—¶æ£€æŸ¥ä»»åŠ¡
        logger.info(f"{self.PLUGIN_NAME} æ’ä»¶å·²åˆå§‹åŒ–ï¼Œå¼€å§‹å®šæ—¶æ£€æŸ¥æ–°è§†é¢‘")
        asyncio.create_task(self.check_new_videos())
    
    # è¯»å–é…ç½®
    def load_config(self):
        if os.path.exists(self.CONFIG_FILE):
            try:
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                if 'last_video_info' in config:
                    self.last_video_info = config['last_video_info']
                if 'subscriptions' in config:
                    self.subscriptions = config['subscriptions']
                logger.info(f"æˆåŠŸåŠ è½½é…ç½®ï¼Œå½“å‰è®¢é˜…UPä¸»æ•°é‡: {sum(1 for subs in self.subscriptions.values() for _ in subs)}")
            except Exception as e:
                logger.error(f"åŠ è½½é…ç½®å¤±è´¥: {e}")
                self._create_default_config()
        else:
            self._create_default_config()
    
    # åˆ›å»ºé»˜è®¤é…ç½®
    def _create_default_config(self):
        config = {'last_video_info': {}, 'subscriptions': {}}
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶æˆåŠŸ")
        except Exception as e:
            logger.error(f"åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    # è·å–UPä¸»æœ€æ–°è§†é¢‘ä¿¡æ¯
    def get_up_latest_video(self, up_id: str) -> Optional[Dict[str, Any]]:
        try:
            # ä½¿ç”¨Bç«™APIè·å–UPä¸»æœ€æ–°è§†é¢‘ - æ›´æ–°ä¸ºæ›´ç¨³å®šçš„æ¥å£
            url = f"https://api.bilibili.com/x/space/arc/search?mid={up_id}&ps=1&tid=0&pn=1&keyword=&order=pubdate&jsonp=jsonp"
            # æ·»åŠ æ›´å®Œæ•´çš„æµè§ˆå™¨æ¨¡æ‹Ÿå¤´ä¿¡æ¯
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'zh-CN,zh;q=0.9',
                'Referer': f'https://space.bilibili.com/{up_id}/',
                'Connection': 'keep-alive',
                'Cache-Control': 'no-cache'
            }
            response = requests.get(url, headers=headers, timeout=10)
            data = response.json()
            
            # è®°å½•APIå“åº”çŠ¶æ€
            if data['code'] != 0:
                logger.warning(f"Bç«™APIè¿”å›é”™è¯¯: code={data['code']}, message={data['message']}")
                
            if data['code'] == 0 and 'data' in data and 'list' in data['data'] and 'vlist' in data['data']['list'] and data['data']['list']['vlist']:
                video = data['data']['list']['vlist'][0]
                return {
                    'aid': video['aid'],
                    'title': video['title'],
                    'pubdate': video['created'],
                    'bvid': video.get('bvid', ''),
                    'description': video.get('description', '')
                }
            # å¦‚æœç¬¬ä¸€æ¬¡è¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å¤‡ç”¨API
            logger.warning(f"æœªè·å–åˆ°UPä¸» {up_id} çš„è§†é¢‘ä¿¡æ¯ï¼Œå°è¯•å¤‡ç”¨API")
            
            # å¤‡ç”¨API - ä½¿ç”¨XMLæ ¼å¼çš„è€æ¥å£
            alt_url = f"https://space.bilibili.com/ajax/member/getSubmitVideos?mid={up_id}&pagesize=1&page=1"
            alt_response = requests.get(alt_url, headers=headers, timeout=10)
            alt_data = alt_response.json()
            
            if alt_data.get('status') and alt_data.get('data') and alt_data['data'].get('vlist'):
                video = alt_data['data']['vlist'][0]
                return {
                    'aid': video['aid'],
                    'title': video['title'],
                    'pubdate': video['created'],
                    'bvid': video.get('bvid', ''),
                    'description': video.get('description', '')
                }
            
            logger.warning(f"å¤‡ç”¨APIä¹Ÿæœªè·å–åˆ°UPä¸» {up_id} çš„è§†é¢‘ä¿¡æ¯")
            return None
        except Exception as e:
            logger.error(f"è·å–UPä¸»è§†é¢‘ä¿¡æ¯å¤±è´¥: {type(e).__name__}: {e}")
            return None
    
    # ä¿å­˜é…ç½®
    def save_config(self):
        config = {
            'last_video_info': self.last_video_info,
            'subscriptions': self.subscriptions
        }
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("é…ç½®ä¿å­˜æˆåŠŸ")
        except Exception as e:
            logger.error(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
    
    # è®¢é˜…UPä¸»
    def subscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id not in self.subscriptions:
            self.subscriptions[user_id] = []
        if up_id not in self.subscriptions[user_id]:
            self.subscriptions[user_id].append(up_id)
            self.save_config()
            logger.info(f"ç”¨æˆ· {user_id} è®¢é˜…äº†UPä¸» {up_id}")
            return True, f"æˆåŠŸè®¢é˜…UPä¸» {up_id}"
        return False, f"ä½ å·²ç»è®¢é˜…äº†UPä¸» {up_id}"
    
    # å–æ¶ˆè®¢é˜…UPä¸»
    def unsubscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id in self.subscriptions and up_id in self.subscriptions[user_id]:
            self.subscriptions[user_id].remove(up_id)
            self.save_config()
            logger.info(f"ç”¨æˆ· {user_id} å–æ¶ˆè®¢é˜…äº†UPä¸» {up_id}")
            return True, f"æˆåŠŸå–æ¶ˆè®¢é˜…UPä¸» {up_id}"
        return False, f"ä½ æ²¡æœ‰è®¢é˜…UPä¸» {up_id}"
    
    # æŸ¥çœ‹è®¢é˜…åˆ—è¡¨
    def get_subscriptions(self, user_id: str) -> str:
        if user_id in self.subscriptions and self.subscriptions[user_id]:
            return f"ä½ è®¢é˜…çš„UPä¸»åˆ—è¡¨: {', '.join(self.subscriptions[user_id])}"
        return "ä½ è¿˜æ²¡æœ‰è®¢é˜…ä»»ä½•UPä¸»"
    
    # å®šæ—¶æ£€æŸ¥æ–°è§†é¢‘
    async def check_new_videos(self):
        """å®šæ—¶æ£€æŸ¥UPä¸»æ˜¯å¦å‘å¸ƒæ–°è§†é¢‘"""
        while True:
            try:
                # è·å–æ‰€æœ‰éœ€è¦æ£€æŸ¥çš„UPä¸»ID
                all_up_ids = set()
                for user_subs in self.subscriptions.values():
                    all_up_ids.update(user_subs)
                
                logger.debug(f"å¼€å§‹æ£€æŸ¥æ–°è§†é¢‘ï¼Œå…± {len(all_up_ids)} ä¸ªUPä¸»")
                
                # æ£€æŸ¥æ¯ä¸ªUPä¸»
                for up_id in all_up_ids:
                    latest_video = self.get_up_latest_video(up_id)
                    if latest_video:
                        # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°è§†é¢‘
                        if up_id not in self.last_video_info or latest_video['pubdate'] > self.last_video_info[up_id].get('pubdate', 0):
                            self.last_video_info[up_id] = latest_video
                            self.save_config()
                            
                            # é€šçŸ¥æ‰€æœ‰è®¢é˜…è¯¥UPä¸»çš„ç”¨æˆ·
                            for user_id, user_subs in self.subscriptions.items():
                                if up_id in user_subs:
                                    # ä½¿ç”¨contextå‘é€æ¶ˆæ¯
                                    try:
                                        # æ„å»ºæ¶ˆæ¯å†…å®¹
                                        message = f"ğŸ‰ UPä¸» {up_id} å‘å¸ƒäº†æ–°è§†é¢‘ï¼\n"
                                        message += f"ğŸ“º æ ‡é¢˜ï¼š{latest_video['title']}\n"
                                        message += f"ğŸ”— é“¾æ¥ï¼šhttps://www.bilibili.com/video/{latest_video.get('bvid', latest_video['aid'])}\n"
                                        
                                        # å‘é€æ¶ˆæ¯
                                        await self.context.send_message(
                                            user_id=user_id,
                                            content=message
                                        )
                                        logger.info(f"å‘é€é€šçŸ¥ç»™ç”¨æˆ· {user_id}: {latest_video['title']}")
                                    except Exception as e:
                                        logger.error(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
            except Exception as e:
                logger.error(f"æ£€æŸ¥æ–°è§†é¢‘æ—¶å‡ºé”™: {e}")
            
            # æ¯å°æ—¶æ£€æŸ¥4æ¬¡ï¼ˆ15åˆ†é’Ÿ=900ç§’ï¼‰
            logger.debug(f"æ£€æŸ¥å®Œæˆï¼Œç­‰å¾…900ç§’åå†æ¬¡æ£€æŸ¥")
            await asyncio.sleep(900)
    
    # è®¢é˜…UPä¸»æŒ‡ä»¤
    @filter.command("bili_sub")
    async def bilibili_subscribe(self, event: AstrMessageEvent):
        '''è®¢é˜…Bç«™UPä¸»ï¼Œä½¿ç”¨æ–¹æ³•ï¼š/bili_sub UPä¸»ID''' 
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # å°è¯•ä¸åŒçš„æ–¹å¼è·å–ç”¨æˆ·IDï¼Œé€‚é…ä¸åŒç‰ˆæœ¬çš„AstrBot
            try:
                # å°è¯•ä»messageå¯¹è±¡ä¸­ç›´æ¥è·å–user_id
                if hasattr(event, 'user_id'):
                    user_id = event.user_id
                # å°è¯•ä»message_objä¸­è·å–
                elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                    user_id = event.message_obj.sender.user_id
                # å°è¯•é€šè¿‡get_senderæ–¹æ³•è·å–
                elif hasattr(event, 'get_sender'):
                    user_id = event.get_sender()
                else:
                    # é»˜è®¤ä½¿ç”¨æ¶ˆæ¯ä¸­çš„ç”¨æˆ·ID
                    user_id = str(event.get('user_id', ''))
            except:
                user_id = str(hash(message_str))[:8]  # ä½œä¸ºå›é€€æ–¹æ¡ˆ
                
            success, reply = self.subscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("ä½¿ç”¨æ–¹æ³•: /bili_sub UPä¸»ID")
    
    # å–æ¶ˆè®¢é˜…UPä¸»æŒ‡ä»¤
    @filter.command("bili_unsub")
    async def bilibili_unsubscribe(self, event: AstrMessageEvent):
        '''å–æ¶ˆè®¢é˜…Bç«™UPä¸»ï¼Œä½¿ç”¨æ–¹æ³•ï¼š/bili_unsub UPä¸»ID'''
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # å°è¯•ä¸åŒçš„æ–¹å¼è·å–ç”¨æˆ·IDï¼Œé€‚é…ä¸åŒç‰ˆæœ¬çš„AstrBot
            try:
                # å°è¯•ä»messageå¯¹è±¡ä¸­ç›´æ¥è·å–user_id
                if hasattr(event, 'user_id'):
                    user_id = event.user_id
                # å°è¯•ä»message_objä¸­è·å–
                elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                    user_id = event.message_obj.sender.user_id
                # å°è¯•é€šè¿‡get_senderæ–¹æ³•è·å–
                elif hasattr(event, 'get_sender'):
                    user_id = event.get_sender()
                else:
                    # é»˜è®¤ä½¿ç”¨æ¶ˆæ¯ä¸­çš„ç”¨æˆ·ID
                    user_id = str(event.get('user_id', ''))
            except:
                user_id = str(hash(message_str))[:8]  # ä½œä¸ºå›é€€æ–¹æ¡ˆ
                
            success, reply = self.unsubscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("ä½¿ç”¨æ–¹æ³•: /bili_unsub UPä¸»ID")
    
    # æŸ¥çœ‹è®¢é˜…åˆ—è¡¨æŒ‡ä»¤
    @filter.command("bili_list")
    async def bilibili_list(self, event: AstrMessageEvent):
        '''æŸ¥çœ‹å·²è®¢é˜…çš„Bç«™UPä¸»åˆ—è¡¨'''
        # å°è¯•ä¸åŒçš„æ–¹å¼è·å–ç”¨æˆ·IDï¼Œé€‚é…ä¸åŒç‰ˆæœ¬çš„AstrBot
        try:
            # å°è¯•ä»messageå¯¹è±¡ä¸­ç›´æ¥è·å–user_id
            if hasattr(event, 'user_id'):
                user_id = event.user_id
            # å°è¯•ä»message_objä¸­è·å–
            elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                user_id = event.message_obj.sender.user_id
            # å°è¯•é€šè¿‡get_senderæ–¹æ³•è·å–
            elif hasattr(event, 'get_sender'):
                user_id = event.get_sender()
            else:
                # é»˜è®¤ä½¿ç”¨æ¶ˆæ¯ä¸­çš„ç”¨æˆ·ID
                user_id = str(event.get('user_id', ''))
        except:
            user_id = str(hash(event.message_str))[:8]  # ä½œä¸ºå›é€€æ–¹æ¡ˆ
            
        reply = self.get_subscriptions(user_id)
        yield event.plain_result(reply)
    
    # å¸®åŠ©æŒ‡ä»¤
    @filter.command("bili_help")
    async def bilibili_help(self, event: AstrMessageEvent):
        '''æŸ¥çœ‹Bç«™UPä¸»è§†é¢‘é€šçŸ¥æ’ä»¶çš„ä½¿ç”¨å¸®åŠ©'''
        help_text = (
            "Bç«™UPä¸»è§†é¢‘é€šçŸ¥æ’ä»¶ä½¿ç”¨å¸®åŠ©ï¼š\n"
            "/bili_sub UPä¸»ID - è®¢é˜…UPä¸»\n"
            "/bili_unsub UPä¸»ID - å–æ¶ˆè®¢é˜…UPä¸»\n"
            "/bili_list - æŸ¥çœ‹è®¢é˜…åˆ—è¡¨\n"
            "/bili_help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
        )
        yield event.plain_result(help_text)
    
    # æ’ä»¶åœç”¨å›è°ƒ
    async def terminate(self):
        '''æ’ä»¶è¢«å¸è½½/åœç”¨æ—¶è°ƒç”¨'''
        logger.info(f"{self.PLUGIN_NAME} æ’ä»¶å·²åœç”¨")
        # è¿™é‡Œå¯ä»¥æ·»åŠ æ¸…ç†èµ„æºçš„ä»£ç 