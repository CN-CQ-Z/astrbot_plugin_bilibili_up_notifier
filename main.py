import asyncio
import json
import os
import uuid
from pathlib import Path
from typing import Dict, Any, List, Optional

# ä½¿ç”¨å¼‚æ­¥HTTPå®¢æˆ·ç«¯æ›¿ä»£åŒæ­¥çš„requests
import httpx

# å¯¼å…¥AstrBot API
from astrbot.api.event import filter, AstrMessageEvent, MessageEventResult
from astrbot.api.star import Context, Star, register, StarTools
from astrbot.api import logger

@register("bilibili_up_notifier", "AutoGenerated", "æ£€æµ‹Bç«™UPä¸»å‘å¸ƒæ–°è§†é¢‘å¹¶æé†’", "1.0.0", "https://github.com")
class BilibiliUpNotifier(Star):
    def __init__(self, context: Context):
        super().__init__(context)
        # æ’ä»¶åç§°å’Œæè¿°
        self.PLUGIN_NAME = "bilibili_up_notifier"
        self.PLUGIN_DESCRIPTION = "æ£€æµ‹Bç«™UPä¸»å‘å¸ƒæ–°è§†é¢‘å¹¶æé†’"
        
        # å­˜å‚¨UPä¸»æœ€åå‘å¸ƒè§†é¢‘çš„ä¿¡æ¯
        self.last_video_info = {}
        # å­˜å‚¨ç”¨æˆ·è®¢é˜…å…³ç³»
        self.subscriptions = {}
        # ä¸Šä¸‹æ–‡å¯¹è±¡
        self.context = context
        # åå°ä»»åŠ¡å¼•ç”¨
        self.check_task = None
        
        # è·å–æ’ä»¶æ•°æ®ç›®å½•
        data_dir = StarTools.get_data_dir(self.PLUGIN_NAME)
        data_dir.mkdir(parents=True, exist_ok=True)  # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.CONFIG_FILE = data_dir / 'config.json'  # ä½¿ç”¨Pathå¯¹è±¡
        
        # åŠ è½½é…ç½®
        self.load_config()
        
        # å¯åŠ¨å®šæ—¶æ£€æŸ¥ä»»åŠ¡å¹¶ä¿å­˜ä»»åŠ¡å¼•ç”¨
        logger.info(f"{self.PLUGIN_NAME} æ’ä»¶å·²åˆå§‹åŒ–ï¼Œå¼€å§‹å®šæ—¶æ£€æŸ¥æ–°è§†é¢‘")
        self.check_task = asyncio.create_task(self.check_new_videos())
    
    # è¯»å–é…ç½®
    def load_config(self):
        if os.path.exists(self.CONFIG_FILE):
            try:
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                if 'last_video_info' in config:
                    self.last_video_info = config['last_video_info']
                if 'subscriptions' in config:
                    self.subscriptions = config['subscriptions']
                logger.info(f"æˆåŠŸåŠ è½½é…ç½®ï¼Œå½“å‰è®¢é˜…UPä¸»æ•°é‡: {sum(1 for subs in self.subscriptions.values() for _ in subs)}")
            except Exception as e:
                logger.error(f"åŠ è½½é…ç½®å¤±è´¥: {e}")
                self._create_default_config()
        else:
            self._create_default_config()
    
    # åˆ›å»ºé»˜è®¤é…ç½®
    def _create_default_config(self):
        config = {'last_video_info': {}, 'subscriptions': {}}
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶æˆåŠŸ")
        except Exception as e:
            logger.error(f"åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    # è·å–UPä¸»æœ€æ–°è§†é¢‘ä¿¡æ¯ - æ”¹ä¸ºå¼‚æ­¥æ–¹æ³•
    async def get_up_latest_video(self, up_id: str) -> Optional[Dict[str, Any]]:
        try:
            # ä½¿ç”¨Bç«™APIè·å–UPä¸»æœ€æ–°è§†é¢‘ - æ›´æ–°ä¸ºæ›´ç¨³å®šçš„æ¥å£
            url = f"https://api.bilibili.com/x/space/arc/search?mid={up_id}&ps=1&tid=0&pn=1&keyword=&order=pubdate&jsonp=jsonp"
            # æ·»åŠ æ›´å®Œæ•´çš„æµè§ˆå™¨æ¨¡æ‹Ÿå¤´ä¿¡æ¯
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'zh-CN,zh;q=0.9',
                'Referer': f'https://space.bilibili.com/{up_id}/',
                'Connection': 'keep-alive',
                'Cache-Control': 'no-cache'
            }
            
            # ä½¿ç”¨å¼‚æ­¥HTTPå®¢æˆ·ç«¯
            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, timeout=10)
                response.raise_for_status()  # æ£€æŸ¥HTTPé”™è¯¯
                data = response.json()
                
                # è®°å½•APIå“åº”çŠ¶æ€
                if data['code'] != 0:
                    logger.warning(f"Bç«™APIè¿”å›é”™è¯¯: code={data['code']}, message={data['message']}")
                    
                if data['code'] == 0 and 'data' in data and 'list' in data['data'] and 'vlist' in data['data']['list'] and data['data']['list']['vlist']:
                    video = data['data']['list']['vlist'][0]
                    return {
                        'aid': video['aid'],
                        'title': video['title'],
                        'pubdate': video['created'],
                        'bvid': video.get('bvid', ''),
                        'description': video.get('description', '')
                    }
                
                # å¦‚æœç¬¬ä¸€æ¬¡è¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å¤‡ç”¨API
                logger.warning(f"æœªè·å–åˆ°UPä¸» {up_id} çš„è§†é¢‘ä¿¡æ¯ï¼Œå°è¯•å¤‡ç”¨API")
                
                # å¤‡ç”¨API - ä½¿ç”¨XMLæ ¼å¼çš„è€æ¥å£
                alt_url = f"https://space.bilibili.com/ajax/member/getSubmitVideos?mid={up_id}&pagesize=1&page=1"
                alt_response = await client.get(alt_url, headers=headers, timeout=10)
                alt_response.raise_for_status()  # æ£€æŸ¥HTTPé”™è¯¯
                alt_data = alt_response.json()
                
                if alt_data.get('status') and alt_data.get('data') and alt_data['data'].get('vlist'):
                    video = alt_data['data']['vlist'][0]
                    return {
                        'aid': video['aid'],
                        'title': video['title'],
                        'pubdate': video['created'],
                        'bvid': video.get('bvid', ''),
                        'description': video.get('description', '')
                    }
                
                logger.warning(f"å¤‡ç”¨APIä¹Ÿæœªè·å–åˆ°UPä¸» {up_id} çš„è§†é¢‘ä¿¡æ¯")
                return None
        except httpx.HTTPError as e:
            logger.error(f"HTTPé”™è¯¯: {type(e).__name__}: {e}")
            return None
        except Exception as e:
            logger.error(f"è·å–UPä¸»è§†é¢‘ä¿¡æ¯å¤±è´¥: {type(e).__name__}: {e}")
            return None
    
    # ä¿å­˜é…ç½®
    def save_config(self):
        config = {
            'last_video_info': self.last_video_info,
            'subscriptions': self.subscriptions
        }
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("é…ç½®ä¿å­˜æˆåŠŸ")
        except Exception as e:
            logger.error(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
    
    # è®¢é˜…UPä¸»
    def subscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id not in self.subscriptions:
            self.subscriptions[user_id] = []
        if up_id not in self.subscriptions[user_id]:
            self.subscriptions[user_id].append(up_id)
            self.save_config()
            logger.info(f"ç”¨æˆ· {user_id} è®¢é˜…äº†UPä¸» {up_id}")
            return True, f"æˆåŠŸè®¢é˜…UPä¸» {up_id}"
        return False, f"ä½ å·²ç»è®¢é˜…äº†UPä¸» {up_id}"
    
    # å–æ¶ˆè®¢é˜…UPä¸»
    def unsubscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id in self.subscriptions and up_id in self.subscriptions[user_id]:
            self.subscriptions[user_id].remove(up_id)
            self.save_config()
            logger.info(f"ç”¨æˆ· {user_id} å–æ¶ˆè®¢é˜…äº†UPä¸» {up_id}")
            return True, f"æˆåŠŸå–æ¶ˆè®¢é˜…UPä¸» {up_id}"
        return False, f"ä½ æ²¡æœ‰è®¢é˜…UPä¸» {up_id}"
    
    # æŸ¥çœ‹è®¢é˜…åˆ—è¡¨
    def get_subscriptions(self, user_id: str) -> str:
        if user_id in self.subscriptions and self.subscriptions[user_id]:
            return f"ä½ è®¢é˜…çš„UPä¸»åˆ—è¡¨: {', '.join(self.subscriptions[user_id])}"
        return "ä½ è¿˜æ²¡æœ‰è®¢é˜…ä»»ä½•UPä¸»"
    
    # å®šæ—¶æ£€æŸ¥æ–°è§†é¢‘
    async def check_new_videos(self):
        """å®šæ—¶æ£€æŸ¥UPä¸»æ˜¯å¦å‘å¸ƒæ–°è§†é¢‘"""
        while True:
            try:
                # è·å–æ‰€æœ‰éœ€è¦æ£€æŸ¥çš„UPä¸»ID
                all_up_ids = set()
                for user_subs in self.subscriptions.values():
                    all_up_ids.update(user_subs)
                
                logger.debug(f"å¼€å§‹æ£€æŸ¥æ–°è§†é¢‘ï¼Œå…± {len(all_up_ids)} ä¸ªUPä¸»")
                
                # æ£€æŸ¥æ¯ä¸ªUPä¸»ï¼ˆä½¿ç”¨awaitè°ƒç”¨å¼‚æ­¥æ–¹æ³•ï¼‰
                for up_id in all_up_ids:
                    latest_video = await self.get_up_latest_video(up_id)
                    if latest_video:
                        # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°è§†é¢‘
                        if up_id not in self.last_video_info or latest_video['pubdate'] > self.last_video_info[up_id].get('pubdate', 0):
                            self.last_video_info[up_id] = latest_video
                            self.save_config()
                            
                            # é€šçŸ¥æ‰€æœ‰è®¢é˜…è¯¥UPä¸»çš„ç”¨æˆ·
                            for user_id, user_subs in self.subscriptions.items():
                                if up_id in user_subs:
                                    # ä½¿ç”¨contextå‘é€æ¶ˆæ¯
                                    try:
                                        # æ„å»ºæ¶ˆæ¯å†…å®¹
                                        message = f"ğŸ‰ UPä¸» {up_id} å‘å¸ƒäº†æ–°è§†é¢‘ï¼\n"
                                        message += f"ğŸ“º æ ‡é¢˜ï¼š{latest_video['title']}\n"
                                        message += f"ğŸ”— é“¾æ¥ï¼šhttps://www.bilibili.com/video/{latest_video.get('bvid', latest_video['aid'])}\n"
                                        
                                        # å‘é€æ¶ˆæ¯
                                        await self.context.send_message(
                                            user_id=user_id,
                                            content=message
                                        )
                                        logger.info(f"å‘é€é€šçŸ¥ç»™ç”¨æˆ· {user_id}: {latest_video['title']}")
                                    except Exception as e:
                                        logger.error(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
            except Exception as e:
                logger.error(f"æ£€æŸ¥æ–°è§†é¢‘æ—¶å‡ºé”™: {e}")
            
            # æ¯å°æ—¶æ£€æŸ¥4æ¬¡ï¼ˆ15åˆ†é’Ÿ=900ç§’ï¼‰
            logger.debug(f"æ£€æŸ¥å®Œæˆï¼Œç­‰å¾…900ç§’åå†æ¬¡æ£€æŸ¥")
            await asyncio.sleep(900)
    
    # è¾…åŠ©æ–¹æ³•ï¼šä»äº‹ä»¶ä¸­è·å–ç”¨æˆ·ID
    def _get_user_id_from_event(self, event: AstrMessageEvent) -> str:
        try:
            # å°è¯•ä»messageå¯¹è±¡ä¸­ç›´æ¥è·å–user_id
            if hasattr(event, 'user_id'):
                return str(event.user_id)
            # å°è¯•ä»message_objä¸­è·å–
            elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                return str(event.message_obj.sender.user_id)
            # å°è¯•é€šè¿‡get_senderæ–¹æ³•è·å–
            elif hasattr(event, 'get_sender'):
                sender = event.get_sender()
                return str(sender) if sender else self._generate_stable_user_id(event)
            # å°è¯•è·å–session_idï¼ˆå¦‚æœæ¡†æ¶æ”¯æŒï¼‰
            elif hasattr(event, 'get_session_id'):
                session_id = event.get_session_id()
                return str(session_id) if session_id else self._generate_stable_user_id(event)
            # é»˜è®¤ä½¿ç”¨æ¶ˆæ¯ä¸­çš„user_id
            elif hasattr(event, 'get'):
                user_id_str = str(event.get('user_id', ''))
                if user_id_str:
                    return user_id_str
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·IDå¤±è´¥: {type(e).__name__}: {e}")
        
        # å›é€€æ–¹æ¡ˆï¼šç”Ÿæˆä¸€ä¸ªåŸºäºäº‹ä»¶ä¿¡æ¯çš„ç¨³å®šæ ‡è¯†ç¬¦
        return self._generate_stable_user_id(event)
    
    # ç”Ÿæˆç¨³å®šçš„ç”¨æˆ·æ ‡è¯†ç¬¦ï¼ˆä½œä¸ºæœ€åçš„å›é€€æ–¹æ¡ˆï¼‰
    def _generate_stable_user_id(self, event: AstrMessageEvent) -> str:
        # å°è¯•ä»äº‹ä»¶ä¸­æå–å¤šä¸ªå±æ€§æ¥ç”Ÿæˆç¨³å®šçš„å“ˆå¸Œå€¼
        event_attributes = []
        
        # æ”¶é›†äº‹ä»¶ä¸­çš„å„ç§æ ‡è¯†ç¬¦å±æ€§
        if hasattr(event, 'message_id'):
            event_attributes.append(str(event.message_id))
        if hasattr(event, 'get'):
            if event.get('group_id'):
                event_attributes.append(f"group_{event.get('group_id')}")
            if event.get('discuss_id'):
                event_attributes.append(f"discuss_{event.get('discuss_id')}")
        if hasattr(event, 'message_str'):
            # ä¸ä½¿ç”¨æ•´ä¸ªæ¶ˆæ¯å†…å®¹ï¼Œåªä½¿ç”¨å‰å‡ ä¸ªå­—ç¬¦åŠ ä¸Šé•¿åº¦æ¥å‡å°‘å˜åŒ–
            msg_content = event.message_str
            event_attributes.append(f"msg_{len(msg_content)}_{msg_content[:10]}")
        
        # å¦‚æœæ²¡æœ‰æ”¶é›†åˆ°è¶³å¤Ÿçš„å±æ€§ï¼Œä½¿ç”¨UUIDä½œä¸ºæœ€åçš„æ‰‹æ®µ
        if not event_attributes:
            logger.warning("æ— æ³•ä»äº‹ä»¶ä¸­æå–ä»»ä½•æ ‡è¯†ä¿¡æ¯ï¼Œä½¿ç”¨éšæœºç”Ÿæˆçš„ä¸´æ—¶ID")
            return f"temp_{uuid.uuid4().hex[:8]}"
        
        # ç”ŸæˆåŸºäºæ”¶é›†åˆ°çš„å±æ€§çš„å“ˆå¸Œå€¼
        combined_str = "_".join(event_attributes)
        stable_hash = hash(combined_str) & 0xFFFFFFFF  # è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°
        
        # æ·»åŠ å‰ç¼€ä»¥æ ‡è¯†è¿™æ˜¯ä¸€ä¸ªå›é€€ID
        stable_id = f"fallback_{stable_hash:08x}"
        logger.debug(f"ä¸ºäº‹ä»¶ç”Ÿæˆå›é€€ç”¨æˆ·ID: {stable_id}")
        
        return stable_id
    
    # è®¢é˜…UPä¸»æŒ‡ä»¤
    @filter.command("bili_sub")
    async def bilibili_subscribe(self, event: AstrMessageEvent):
        '''è®¢é˜…Bç«™UPä¸»ï¼Œä½¿ç”¨æ–¹æ³•ï¼š/bili_sub UPä¸»ID''' 
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # ä½¿ç”¨è¾…åŠ©æ–¹æ³•è·å–ç”¨æˆ·ID
            user_id = self._get_user_id_from_event(event)
            
            success, reply = self.subscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("ä½¿ç”¨æ–¹æ³•: /bili_sub UPä¸»ID")
    
    # å–æ¶ˆè®¢é˜…UPä¸»æŒ‡ä»¤
    @filter.command("bili_unsub")
    async def bilibili_unsubscribe(self, event: AstrMessageEvent):
        '''å–æ¶ˆè®¢é˜…Bç«™UPä¸»ï¼Œä½¿ç”¨æ–¹æ³•ï¼š/bili_unsub UPä¸»ID'''
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # ä½¿ç”¨è¾…åŠ©æ–¹æ³•è·å–ç”¨æˆ·ID
            user_id = self._get_user_id_from_event(event)
            
            success, reply = self.unsubscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("ä½¿ç”¨æ–¹æ³•: /bili_unsub UPä¸»ID")
    
    # æŸ¥çœ‹è®¢é˜…åˆ—è¡¨æŒ‡ä»¤
    @filter.command("bili_list")
    async def bilibili_list(self, event: AstrMessageEvent):
        '''æŸ¥çœ‹å·²è®¢é˜…çš„Bç«™UPä¸»åˆ—è¡¨'''
        # ä½¿ç”¨è¾…åŠ©æ–¹æ³•è·å–ç”¨æˆ·ID
        user_id = self._get_user_id_from_event(event)
        
        reply = self.get_subscriptions(user_id)
        yield event.plain_result(reply)
    
    # å¸®åŠ©æŒ‡ä»¤
    @filter.command("bili_help")
    async def bilibili_help(self, event: AstrMessageEvent):
        '''æŸ¥çœ‹Bç«™UPä¸»è§†é¢‘é€šçŸ¥æ’ä»¶çš„ä½¿ç”¨å¸®åŠ©'''
        help_text = (
            "Bç«™UPä¸»è§†é¢‘é€šçŸ¥æ’ä»¶ä½¿ç”¨å¸®åŠ©ï¼š\n"
            "/bili_sub UPä¸»ID - è®¢é˜…UPä¸»\n"
            "/bili_unsub UPä¸»ID - å–æ¶ˆè®¢é˜…UPä¸»\n"
            "/bili_list - æŸ¥çœ‹è®¢é˜…åˆ—è¡¨\n"
            "/bili_help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
        )
        yield event.plain_result(help_text)
    
    # æ’ä»¶åœç”¨å›è°ƒ
    async def terminate(self):
        '''æ’ä»¶è¢«å¸è½½/åœç”¨æ—¶è°ƒç”¨'''
        # æ­£ç¡®å–æ¶ˆåå°ä»»åŠ¡
        if self.check_task:
            self.check_task.cancel()
            try:
                await self.check_task
            except asyncio.CancelledError:
                logger.info("åå°è§†é¢‘æ£€æŸ¥ä»»åŠ¡å·²æˆåŠŸå–æ¶ˆ")
        
        logger.info(f"{self.PLUGIN_NAME} æ’ä»¶å·²åœç”¨ï¼Œèµ„æºå·²æ¸…ç†")