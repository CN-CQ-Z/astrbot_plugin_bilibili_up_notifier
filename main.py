import asyncio
import requests
import json
import os
from typing import Dict, Any, List, Optional

# 导入AstrBot API
from astrbot.api.event import filter, AstrMessageEvent, MessageEventResult
from astrbot.api.star import Context, Star, register
from astrbot.api import logger

@register("bilibili_up_notifier", "AutoGenerated", "检测B站UP主发布新视频并提醒", "1.0.0", "https://github.com")
class BilibiliUpNotifier(Star):
    def __init__(self, context: Context):
        super().__init__(context)
        # 插件名称和描述
        self.PLUGIN_NAME = "bilibili_up_notifier"
        self.PLUGIN_DESCRIPTION = "检测B站UP主发布新视频并提醒"
        
        # 存储UP主最后发布视频的信息
        self.last_video_info = {}
        # 存储用户订阅关系
        self.subscriptions = {}
        # 配置文件路径
        self.CONFIG_FILE = os.path.join(os.path.dirname(__file__), 'config.json')
        # 上下文对象
        self.context = context
        
        # 加载配置
        self.load_config()
        
        # 启动定时检查任务
        logger.info(f"{self.PLUGIN_NAME} 插件已初始化，开始定时检查新视频")
        asyncio.create_task(self.check_new_videos())
    
    # 读取配置
    def load_config(self):
        if os.path.exists(self.CONFIG_FILE):
            try:
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                if 'last_video_info' in config:
                    self.last_video_info = config['last_video_info']
                if 'subscriptions' in config:
                    self.subscriptions = config['subscriptions']
                logger.info(f"成功加载配置，当前订阅UP主数量: {sum(1 for subs in self.subscriptions.values() for _ in subs)}")
            except Exception as e:
                logger.error(f"加载配置失败: {e}")
                self._create_default_config()
        else:
            self._create_default_config()
    
    # 创建默认配置
    def _create_default_config(self):
        config = {'last_video_info': {}, 'subscriptions': {}}
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("创建默认配置文件成功")
        except Exception as e:
            logger.error(f"创建默认配置文件失败: {e}")
    
    # 获取UP主最新视频信息
    def get_up_latest_video(self, up_id: str) -> Optional[Dict[str, Any]]:
        try:
            # 使用B站API获取UP主最新视频 - 更新为更稳定的接口
            url = f"https://api.bilibili.com/x/space/arc/search?mid={up_id}&ps=1&tid=0&pn=1&keyword=&order=pubdate&jsonp=jsonp"
            # 添加更完整的浏览器模拟头信息
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'zh-CN,zh;q=0.9',
                'Referer': f'https://space.bilibili.com/{up_id}/',
                'Connection': 'keep-alive',
                'Cache-Control': 'no-cache'
            }
            response = requests.get(url, headers=headers, timeout=10)
            data = response.json()
            
            # 记录API响应状态
            if data['code'] != 0:
                logger.warning(f"B站API返回错误: code={data['code']}, message={data['message']}")
                
            if data['code'] == 0 and 'data' in data and 'list' in data['data'] and 'vlist' in data['data']['list'] and data['data']['list']['vlist']:
                video = data['data']['list']['vlist'][0]
                return {
                    'aid': video['aid'],
                    'title': video['title'],
                    'pubdate': video['created'],
                    'bvid': video.get('bvid', ''),
                    'description': video.get('description', '')
                }
            # 如果第一次请求失败，尝试使用备用API
            logger.warning(f"未获取到UP主 {up_id} 的视频信息，尝试备用API")
            
            # 备用API - 使用XML格式的老接口
            alt_url = f"https://space.bilibili.com/ajax/member/getSubmitVideos?mid={up_id}&pagesize=1&page=1"
            alt_response = requests.get(alt_url, headers=headers, timeout=10)
            alt_data = alt_response.json()
            
            if alt_data.get('status') and alt_data.get('data') and alt_data['data'].get('vlist'):
                video = alt_data['data']['vlist'][0]
                return {
                    'aid': video['aid'],
                    'title': video['title'],
                    'pubdate': video['created'],
                    'bvid': video.get('bvid', ''),
                    'description': video.get('description', '')
                }
            
            logger.warning(f"备用API也未获取到UP主 {up_id} 的视频信息")
            return None
        except Exception as e:
            logger.error(f"获取UP主视频信息失败: {type(e).__name__}: {e}")
            return None
    
    # 保存配置
    def save_config(self):
        config = {
            'last_video_info': self.last_video_info,
            'subscriptions': self.subscriptions
        }
        try:
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("配置保存成功")
        except Exception as e:
            logger.error(f"保存配置失败: {e}")
    
    # 订阅UP主
    def subscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id not in self.subscriptions:
            self.subscriptions[user_id] = []
        if up_id not in self.subscriptions[user_id]:
            self.subscriptions[user_id].append(up_id)
            self.save_config()
            logger.info(f"用户 {user_id} 订阅了UP主 {up_id}")
            return True, f"成功订阅UP主 {up_id}"
        return False, f"你已经订阅了UP主 {up_id}"
    
    # 取消订阅UP主
    def unsubscribe_up(self, user_id: str, up_id: str) -> tuple[bool, str]:
        if user_id in self.subscriptions and up_id in self.subscriptions[user_id]:
            self.subscriptions[user_id].remove(up_id)
            self.save_config()
            logger.info(f"用户 {user_id} 取消订阅了UP主 {up_id}")
            return True, f"成功取消订阅UP主 {up_id}"
        return False, f"你没有订阅UP主 {up_id}"
    
    # 查看订阅列表
    def get_subscriptions(self, user_id: str) -> str:
        if user_id in self.subscriptions and self.subscriptions[user_id]:
            return f"你订阅的UP主列表: {', '.join(self.subscriptions[user_id])}"
        return "你还没有订阅任何UP主"
    
    # 定时检查新视频
    async def check_new_videos(self):
        """定时检查UP主是否发布新视频"""
        while True:
            try:
                # 获取所有需要检查的UP主ID
                all_up_ids = set()
                for user_subs in self.subscriptions.values():
                    all_up_ids.update(user_subs)
                
                logger.debug(f"开始检查新视频，共 {len(all_up_ids)} 个UP主")
                
                # 检查每个UP主
                for up_id in all_up_ids:
                    latest_video = self.get_up_latest_video(up_id)
                    if latest_video:
                        # 检查是否是新视频
                        if up_id not in self.last_video_info or latest_video['pubdate'] > self.last_video_info[up_id].get('pubdate', 0):
                            self.last_video_info[up_id] = latest_video
                            self.save_config()
                            
                            # 通知所有订阅该UP主的用户
                            for user_id, user_subs in self.subscriptions.items():
                                if up_id in user_subs:
                                    # 使用context发送消息
                                    try:
                                        # 构建消息内容
                                        message = f"🎉 UP主 {up_id} 发布了新视频！\n"
                                        message += f"📺 标题：{latest_video['title']}\n"
                                        message += f"🔗 链接：https://www.bilibili.com/video/{latest_video.get('bvid', latest_video['aid'])}\n"
                                        
                                        # 发送消息
                                        await self.context.send_message(
                                            user_id=user_id,
                                            content=message
                                        )
                                        logger.info(f"发送通知给用户 {user_id}: {latest_video['title']}")
                                    except Exception as e:
                                        logger.error(f"发送消息失败: {e}")
            except Exception as e:
                logger.error(f"检查新视频时出错: {e}")
            
            # 每小时检查4次（15分钟=900秒）
            logger.debug(f"检查完成，等待900秒后再次检查")
            await asyncio.sleep(900)
    
    # 订阅UP主指令
    @filter.command("bili_sub")
    async def bilibili_subscribe(self, event: AstrMessageEvent):
        '''订阅B站UP主，使用方法：/bili_sub UP主ID''' 
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # 尝试不同的方式获取用户ID，适配不同版本的AstrBot
            try:
                # 尝试从message对象中直接获取user_id
                if hasattr(event, 'user_id'):
                    user_id = event.user_id
                # 尝试从message_obj中获取
                elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                    user_id = event.message_obj.sender.user_id
                # 尝试通过get_sender方法获取
                elif hasattr(event, 'get_sender'):
                    user_id = event.get_sender()
                else:
                    # 默认使用消息中的用户ID
                    user_id = str(event.get('user_id', ''))
            except:
                user_id = str(hash(message_str))[:8]  # 作为回退方案
                
            success, reply = self.subscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("使用方法: /bili_sub UP主ID")
    
    # 取消订阅UP主指令
    @filter.command("bili_unsub")
    async def bilibili_unsubscribe(self, event: AstrMessageEvent):
        '''取消订阅B站UP主，使用方法：/bili_unsub UP主ID'''
        message_str = event.message_str.strip()
        parts = message_str.split()
        if len(parts) >= 2:
            up_id = parts[1]
            # 尝试不同的方式获取用户ID，适配不同版本的AstrBot
            try:
                # 尝试从message对象中直接获取user_id
                if hasattr(event, 'user_id'):
                    user_id = event.user_id
                # 尝试从message_obj中获取
                elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                    user_id = event.message_obj.sender.user_id
                # 尝试通过get_sender方法获取
                elif hasattr(event, 'get_sender'):
                    user_id = event.get_sender()
                else:
                    # 默认使用消息中的用户ID
                    user_id = str(event.get('user_id', ''))
            except:
                user_id = str(hash(message_str))[:8]  # 作为回退方案
                
            success, reply = self.unsubscribe_up(user_id, up_id)
            yield event.plain_result(reply)
        else:
            yield event.plain_result("使用方法: /bili_unsub UP主ID")
    
    # 查看订阅列表指令
    @filter.command("bili_list")
    async def bilibili_list(self, event: AstrMessageEvent):
        '''查看已订阅的B站UP主列表'''
        # 尝试不同的方式获取用户ID，适配不同版本的AstrBot
        try:
            # 尝试从message对象中直接获取user_id
            if hasattr(event, 'user_id'):
                user_id = event.user_id
            # 尝试从message_obj中获取
            elif hasattr(event, 'message_obj') and hasattr(event.message_obj, 'sender'):
                user_id = event.message_obj.sender.user_id
            # 尝试通过get_sender方法获取
            elif hasattr(event, 'get_sender'):
                user_id = event.get_sender()
            else:
                # 默认使用消息中的用户ID
                user_id = str(event.get('user_id', ''))
        except:
            user_id = str(hash(event.message_str))[:8]  # 作为回退方案
            
        reply = self.get_subscriptions(user_id)
        yield event.plain_result(reply)
    
    # 帮助指令
    @filter.command("bili_help")
    async def bilibili_help(self, event: AstrMessageEvent):
        '''查看B站UP主视频通知插件的使用帮助'''
        help_text = (
            "B站UP主视频通知插件使用帮助：\n"
            "/bili_sub UP主ID - 订阅UP主\n"
            "/bili_unsub UP主ID - 取消订阅UP主\n"
            "/bili_list - 查看订阅列表\n"
            "/bili_help - 显示帮助信息"
        )
        yield event.plain_result(help_text)
    
    # 插件停用回调
    async def terminate(self):
        '''插件被卸载/停用时调用'''
        logger.info(f"{self.PLUGIN_NAME} 插件已停用")
        # 这里可以添加清理资源的代码